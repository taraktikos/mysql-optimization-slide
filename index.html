<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Оптимізація MySql</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/serif.css" id="theme">
		<link rel="stylesheet" href="css/custom.css" >

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>
		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<section>
                    <img src="img/mysql.png"/>
                    <h2>Performance Optimization</h2>
				</section>

                <section data-markdown>
                    ## План

                    * Іторія MySql
                    * Архітектура
                    * Тюнінг mysql
                    * Утиліти
                    * Запити
                    * Поради
                </section>

                <section>
                    <section>
                        <h3>Іторія MySql</h3>
                        <div class="simple-text">
                            <p>
                                Винахідником MySQL являється Майкл Монті Віденіус (aka Monty) із шведської компанії TcX. В 1979 році він розробив засіб
                                управління базами даних, яке називалось UNIREG.
                            </p>
                            <p>
                                В цей час на ринку існувала база даних <strong>mSQL (MiniSQL)</strong> — легка клієнт-серверна реляційна СУБД, створена
                                компанією Hughes Technologies. (Давид Хьюз)
                            </p>
                            <p>
                                Після невдалої спроби злиття цих проектів в TcX взяли за основу UNIREG і використовували утиліти сторонніх розробників для
                                mSQL, написали АРІ для своєї системи, який спочатку дуже співпадав з API для mSQL.
                            </p>
                            <p>
                                Таким чином, в травні 1995 року у компанії була база даних MySQL 1.0, яка повністтю задовольняла її потреби.
                            </p>
                            <p>
                                Що стосується назви, то існує два варіанти: або тому, що практично всі напрацювання компанії починалися з префікса My,
                                або на честь дівчинки на ім'я My, дочки Майкла Монті Віденіуса.
                            </p>
                            <p>
                                В січні-лютому 2008 Sun Microsystems придбала розробку системи керування базами данних MySQL за $1 млрд.
                                Після поглинання у 2009 році Sun Microsystems компанією Oracle Corporation MySQL стала власністю Oracle.
                            </p>
                            <p><strong>Остання стабільна версія 5.6 (05.02.2013)</strong></p>
                        </div>
                    </section>
                </section>

                <section>

                    <section>
                        <h3>Логінча архітектура MySql</h3>
                        <img src="img/mysql_architecture.png">
                    </section>

                    <section>
                        <img height="100" style="float: right; margin-top: -45px;" src="img/connection.jpg">
                        <h3>Керування з'єднанями</h3>
                        <p style="text-align: justify">
                            Для кожного клієнтського з'єднання виділяється окремий потік в середині процеса сервера.
                            Запити по даному з'єднанню виконуються в межах цього потоку. Сервер кешує потоки, так що їх
                            не приходиться створювати або видаляти для кожного нового з'єднання.
                        </p>
                        <p style="text-align: justify">
                            Ідентифікація клієнтів основується на імені користувача, адресі хоста і паролю.
                            Після ідентифікації сервер перевіряє наявність відповідних превілегій. Наприклад
                            можливість виконувати команду SELECT для певної таблиці.
                        </p>
                    </section>

                    <section>
                        <h3>Оптимізація та виконання</h3>
                        <p style="text-align: justify">
                            MySQL виконує синтаксичний розбір запитів для створення внутрішньої структури (дерева розбору),
                            а потім виконує ряд оптимізацій. До них належать переписування запиту, виявлення порядку читання таблиць,
                            вибір використовуваних індексів і т.д. Ми можемо повпливати на роботу оптимізатора, включивши в запит спеціальні
                            ключові слова-підказки.
                        </p>
                        <p style="text-align: justify">
                            Перш ніж виконати синтаксичний аналіз запиту, сервер звертається до кешу запитів, в якому знаходяться тільки
                            команди SELECT і відповіді їм результати.
                        </p>
                    </section>

                    <section>
                        <h3>Керування конкурентним доступом</h3>

                        <p style="text-align: justify">
                            В будь-який момент може виникнути ситуація, при якій відразу декільком запитам необхідно одночасно змінити дані,
                            в результаті чого виникає задача керування конкурентним доступом.
                        </p>
                    </section>

                    <section>
                        <h3>Блокування читання/запису</h3>

                        <p style="text-align: justify">
                            Блокування при читанні ресурсу являються розділяючі, тобто взаємно не блокуючі.
                        </p>
                        <p style="text-align: justify">
                            Блокування запису, навпаки, являється монопольним.
                            Також блокування запису мають більш високий пріорітет, тому такі запити поміщаються в черзі перед уже існуючими
                            запитами блокування читання.
                        </p>
                    </section>

                    <section>
                        <p style="text-align: justify">
                            <strong>Блокування на рівні таблиць</strong> (MyIsam) <br/>
                            Для таких команд як ALTER TABLE, сервер реалізовує табличне блокування не залежно від підсистеми збереження даних.
                        </p>
                        <p style="text-align: justify">
                            <strong>Блокування рядків</strong> (InnoDB и Falcon) <br/>
                            Більші можливосі конкурентного доступу, але і більші накладні витрати.
                        </p>
                    </section>

                    <section>
                        <h3>Транзакции</h3>
                        <p>
                            Транзакцією називається атомарна група запитів SQL
                        </p>

                        <pre><code>
START TRANSACTION;
SELECT balance FROM checking WHERE customer_id = 10233276;
UPDATE checking SET balance = balance - 200.00 WHERE customer_id = 10233276;
UPDATE savings SET balance = balance + 200.00 WHERE customer_id = 10233276;
COMMIT;
                        </code></pre>
                    </section>

                    <section>
                        <h3>ACID</h3>
                        <p style="text-align: justify">
                            Транзакцій недостатньо, якщо система не проходе тест ACID (Atomicity, Consistency, Isolation, Durability) <br/>
                            (Атомарність, несуперечливість, ізольованість, довговічність)
                        </p>
                    </section>

                    <section>
                        <h3>Рівні ізоляції</h3>
                        <p style="text-align: justify">
                            Стандарт SQL визначає 4 рівні ізоляції з конкретними правилами, що встановлюють які зміни доступні в середині транзакції,
                            а які ні.
                        </p>
                    </section>

                    <section>
                        <ul style="list-style: none; font-size: 22px">
                            <li>
                                <strong>READ UNCOMMITTED</strong> - транзакції можуть бачити результати незафіксовани транзакцій
                            </li>
                            <li class="fragment">
                                <strong>READ COMMITTED</strong> - транзакції можуть бачити тільки ті зміни, які були зафіксовані
                                іншими транзакціями до моменту її початку, а створені нею зміни будуть невидимі доки вона не буде зафіксована.
                                Можливий феномен <em>неповторюваного читання</em>
                            </li>
                            <li class="fragment">
                                <strong>REPEATABLE READ</strong> (стоїть за замовчуванням) - гарантує, що будь-які рядки які читаються в контексті транзакції
                                будуть такі ж як і при послідовних операціях читання в межах однієї транзації.
                                Можливий феномен <em>фантомного читання</em>
                            </li>
                            <li class="fragment">
                                <strong>SERIALIZABLE</strong> - блокує кожну строку, яку транзакція читає. На цьому рівні виникає
                                багато затримок і конфліктів при блокуваннях.
                            </li>
                        </ul>
                        <div class="fragment">
                            <pre><code>
                                [mysqld]
                                transaction-isolation = REPEATABLE-READ
                            </code></pre>
                        </div>
                    </section>

                    <section>
                        <table class="table-bordered">
                            <thead>
                                <tr>
                                    <th><strong>Рівень ізоляції</strong></th>
                                    <th><strong>Грязне читання</strong></th>
                                    <th><strong>Неповторюване читання</strong></th>
                                    <th><strong>Фантомне читання</strong></th>
                                    <th><strong>Блокування читання</strong></th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>READ UNCOMMITTED</strong></td>
                                    <td>Так</td>
                                    <td>Так</td>
                                    <td>Так</td>
                                    <td>Ні</td>
                                </tr>
                                <tr>
                                    <td><strong>READ COMMITTED</strong></td>
                                    <td>Ні</td>
                                    <td>Так</td>
                                    <td>Так</td>
                                    <td>Ні</td>
                                </tr>
                                <tr>
                                    <td><strong>REPEATABLE READ</strong></td>
                                    <td>Ні</td>
                                    <td>Ні</td>
                                    <td>Так</td>
                                    <td>Ні</td>
                                </tr>
                                <tr>
                                    <td><strong>SERIALIZABLE</strong></td>
                                    <td>Ні</td>
                                    <td>Ні</td>
                                    <td>Ні</td>
                                    <td>Так</td>
                                </tr>
                            </tbody>
                        </table>
                    </section>

                    <section>
                        <h3>Взаємні блокування (deadlocks)</h3>
                        <pre><code>
Транзакция #1
START TRANSACTION;
UPDATE StockPrice SET close = 45.50 WHERE stock_id = 4 and date = ‘2013-05-01’;
UPDATE StockPrice SET close = 19.80 WHERE stock_id = 3 and date = ‘2013-05-02’;
COMMIT;
Транзакция #2
START TRANSACTION;
UPDATE StockPrice SET high = 20.12 WHERE stock_id = 3 and date = ‘2013-05-02’;
UPDATE StockPrice SET high = 47.20 WHERE stock_id = 4 and date = ‘2013-05-01’;
COMMIT;
                        </code></pre>
                        <p style="text-align: justify">
                            Спосіб яким InnoDB обробляє такі ситуації полягає в тому що відміняється та транзакція, яка захватила
                            менше монопольних блокувань рядків. (<em>показник легкості відкату</em>)
                        </p>
                    </section>

                </section>

                <section>
                    <section>
                        <h2>Підсистеми зберігання в MySql</h2>
                    </section>

                    <section>
                        <h3>MyIsam</h3>
                        <ul>
                            <li>Один із найстаріших сховищ в MySQL</li>
                            <li>Швидкий, добре працює у випадку "багато читаємо, мало пишем"</li>
                            <li>Підтримує повнотекстові індекси</li>
                            <li>Індекс - B-tree</li>
                            <li>Підтримується дописування в кінець (коли виконуюються запити на читання (конкурентні вставки))</li>
                            <li>Блокування на рівні таблиць</li>
                            <li>Не підтримується цілісність даних між таблицями</li>
                        </ul>
                    </section>

                    <section>
                        <h3>MyIsam на диску</h3>
                        <ul>
                            <li>Кожна база - це окремий каталог</li>
                            <li>Файли frm описують структуру таблиці</li>
                            <li>MDY/MYI містять дані і індекси відповідно</li>
                            <li>Підтримується перенесення простим копіюванням файлів</li>
                        </ul>
                    </section>

                    <section>
                        <h3>Сховище InnoDB</h3>
                        <ul>
                            <li>Підтримує ACID</li>
                            <li>Блокування на рівні рядка</li>
                            <li>Підтримує зовнішні ключі</li>
                            <li>У версії MySQL 5.6 підтримує повнотекстовий індекс</li>
                        </ul>
                    </section>

                    <section>
                        <h3>InnoDB на диску</h3>
                        <ul>
                            <li>Всі дані зберігаються в загальному просторі даних (ibdata* ніколи не зменшується в розмірі)</li>
                            <li>Можна налаштувати так, щоб дані, які відносяться до одної таблиці зберігались в окремих файлах
                                ibd (параметр <em>innodb_file_per_table</em>)</li>
                        </ul>
                    </section>


                    <section>
                        <h3>MyISAM Merge</h3>
                        <p style="text-align: justify">Це підсистема являється варіацією на тему MyISAM. Таблиця типу Merge представляє собою об'єднання
                            декількох структурно однакових таблиць MyISAM в одну віртуальну таблицю. Корисно використовувати для ведення
                            логів і організації сховищ даних.</p>
                    </section>


                    <section>
                        <h3>Підсистема Memory</h3>
                        <p style="text-align: justify">Корисна коли необхідно виконувати бистрий доступ до даних, якщо нема необхідності
                        в їх збереженні після перезапуску, для кешування періодично агрегованих даних, для проміжних результатів при аналізі даних.
                        Після перезапуску сервера структура зберігається, а дані втрачаються
                        </p>
                        <ul>
                            <li>Підтримуються HASH індекси</li>
                            <li>Блокування на рівні таблиці</li>
                            <li>Не підтримує TEXT і BLOB</li>
                            <li>Допускаються тільки рядки фіксованого розміру (varchar -> char)</li>
                        </ul>
                    </section>

                    <section>
                        <h3>Підсистема Archive</h3>
                        <p style="text-align: justify">Дозволяє виконувати тільки команди INSERT і SELECT. З версії MySQL 5.1 підтримується
                            індексування (в обмеженому вигляді). Рядки які вставляються зжимаються бібліотекою <em>zlib</em>.
                            Кожеш запит SELECT потребує повного сканування.
                        </p>
                        <p style="text-align: justify">Використовується для збору даних, в тих випадках коли при аналізі треба
                            сканувати всю таблицю, а також коли необхідно забезпечити швидке виконання інсертів на головному сервері реплікації.
                        </p>
                    </section>

                    <section>
                        <h3>Підсистема CSV</h3>
                        <p style="text-align: justify">
                            Розглядає CSV файли як таблиці, але не підтримує індекси по них.
                        </p>
                    </section>

                    <section>
                        <h3>Підсистема Blackhole</h3>
                        <p style="text-align: justify">
                            В підсистемі Blackhole взагалі немає механізму зберігання даних. Команди INSERT ігноруються.
                        </p>
                        <p style="text-align: justify">
                            Використовується для налаштування реплікацій і ведення журналу аудиту.
                        </p>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Пошук вузьких місць</h2>
                    </section>

                    <section>
                        <h3>Інструменти компонентного тестування</h3>
                        <ul style="list-style: none;">
                            <li><strong><em><a target="_blank" href="http://dev.mysql.com/doc/refman/5.5/en/mysqlslap.html">mysqlslap</a></em></strong> - емулює навантаження на сервер і показує дані хронометража. Можна налаштувати кількість одночасних з'єднань та передати команди</li>
                            <li><strong><em><a target="_blank" href="http://sysbench.sourceforge.net">sysbench</a></em></strong> - Призначений для представлення продуктивності ОС</li>
                            <li><strong><em><a target="_blank" href="http://sourceforge.net/projects/osdldbt/">Database Test Suite</a></em></strong></li>
                            <li><strong><em><a target="_blank" href="http://dev.mysql.com/doc/refman/5.5/en/mysql-benchmarks.html">MySQL Benchmark Suite</a></em></strong></li>
                            <li>...</li>
                        </ul>
                    </section>

                    <section>
                        <h3>Mysqlslap</h3>
                        <pre><code>
mysqlslap --user=root -proot --auto-generate-sql
          --concurrency=300 --iterations=5 --number-of-queries=100
mysqlslap --user=root -proot test --delimiter=";"
          --create="CREATE TABLE a (b int);INSERT INTO a VALUES (23)"
          --query="SELECT * FROM a" --concurrency=50 --iterations=200
mysqlslap --user=root -proot --create-schema="test_employees"
          --query=query.sql --concurrency=100
                        </code></pre>
                    </section>

                    <section>
                        <h3>Ведення протоколу повільних запитів</h3>
                        <pre><code>
#log_slow_queries < 5.5.24
slow_query_log_file     = /var/log/mysql/mysql-slow.log
slow_query_log          = 1
long_query_time         = 0.1
log-queries-not-using-indexes
                        </code></pre>
                    </section>

                    <section>
                        <h3>Приклад з логу повільних запитів</h3>
                        <pre><code>
# Time: 130508 12:25:33
# User@Host: root[root] @ localhost []  Id:    18
# Query_time: 2.464897  Lock_time: 0.000068 Rows_sent: 1000  Rows_examined: 1000
SET timestamp=1368005133;
SELECT * FROM cities ORDER BY `name` DESC LIMIT 1000;
                        </code></pre>
                    </section>

                    <section>
                        <h3>Інструменти аналізу логів</h3>
                        <ul style="list-style: none;">
                            <li><strong><em>mysqldumpslow</em></strong> - Показує скільки раз кожен запит з'являється в журналі повільних запитів </li>
                            <li><strong><em><a target="_blank" href="http://www.mysqlperformanceblog.com/files/utils/mysql_slow_log_filter">mysql_slow_log_filter</a></em></strong> - Майже як попердній з додатковими параметрами: мінімальний поріг часу та кількість рядків
                            <pre><code>
mysql_slow_log_filter -T 3 -R 1000 < /var/log/mysql/mysql-slow-query.log
                            </code></pre></li>
                            <li><strong><em><a target="_blank" href="http://www.maatkit.org/doc/mk-query-digest.html">mk-query-digest</a></em></strong>
                                <pre><code>
mk-query-digest /var/log/mysql/mysql-slow-query.log
                                </code></pre></li>
                            </li>
                            <li><strong><em><a target="_blank" href="http://www.mysql­performanceblog.com/files/utils/mysql_slow_log_parser">mysql_slow_log_ parser</a></em></strong> - Створює звіт, показує min,max час, запит до якого можна застосувати EXPLAIN</li>
                        </ul>
                    </section>

                    <section>
                        <h3>Команда EXPLAIN</h3>
                        <pre><code>
EXPLAIN SELECT SQL_NO_CACHE emp_no FROM salaries WHERE salary = 8000;
                        </code></pre>
                        <img src="img/explain.png">
                    </section>

                    <section>
                        <h3>Команда EXPLAIN</h3>
                        <ul>
                            <li><strong>select_type</strong> - показує якому запиту відповідає рядок (SIMPLE|PRIMARY|SUBQUERY|DERIVED|UNION|UNION RESULT)</li>
                            <li><strong>table</strong> - до якої таблиці відноситься рядок</li>
                            <li><strong>type</strong> - вказує на метод пошуку рядків (ALL|index|range|ref|eq_ref|const,system|NULL)</li>
                            <li><strong>possible_keys</strong> - показує які індекси можна було б задіяти</li>
                            <li><strong>key</strong> - показує який індекс використовується</li>
                            <li><strong>key_len</strong> - показує яка довжина індекса використовується</li>
                            <li><strong>ref</strong> - показує які стовбці або константи використовуються для пошуку в індексі</li>
                            <li><strong>rows</strong> - скільки рядків треба прочитати щоб знайти результат</li>
                            <li><strong>Extra</strong> - показує додаткову інформацію (Using index|Using where|Using temporary|Using filesort)</li>
                        </ul>
                    </section>

                    <section>
                        <h3>EXPLAIN EXTENDED</h3>
                        <ul>
                            <li><strong>filtered</strong> - показує відсоток рядків що задовольняють заданому критерію</li>
                        </ul>
                        <pre><code>
SHOW WARNINGS\G;
                        </code></pre>
                        <img src="img/explain_extend.png">
                    </section>
                </section>

                <section>

                    <section>
                        <h2>Оптимізація запитів та індексування</h2>
                    </section>

                    <section>
                        <h2>Типи індексів</h2>
                        <ul style="list-style: none;">
                            <li class="fragment">B-Tree індекси</li>
                            <li class="fragment">Хеш-індекси</li>
                            <li class="fragment">Повнотекстові індекси (FULLTEXT)</li>
                        </ul>
                    </section>

                    <section>
                        <h2>B-Tree індекси</h2>
                        <p>Корисні лише в тому випадку коли використовується ліва частина ключа</p>
                        <ul>
                            <li class="fragment">Пошук по значенню ключа</li>
                            <li class="fragment">По діапазону ключів</li>
                            <li class="fragment">По префіксу ключа</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Хеш-індекси</h2>
                        <p>Корисні лише для точного пошуку із використанням всіх стовбців індекса</p>
                        <p>Обмеження</p>
                        <ul>
                            <li class="fragment">Не використовується для сортування</li>
                            <li class="fragment">Не підтримує пошук по частині ключа</li>
                            <li class="fragment">Не підтримує пошук по діапазону</li>
                            <li class="fragment">При збільшенні колізій зменшується швидкість</li>
                        </ul>
                    </section>

                    <section>
                        <h2>Піддослідна база даних "Працівники"</h2>
                        <p>Структура</p>
                        <img src="img/employees.png" />
                        <img src="img/dep_emp.png" />
                        <img src="img/dep.png" />
                        <img src="img/dep_manager.png" />
                        <img src="img/salaries.png" />
                        <img src="img/titles.png" />
                    </section>

                    <section>
                        <h2>Ізоляція стовпця</h2>
                        <p>MySql не може використовувати індекс по стовпцю, якщо він не ізольований в запиті</p>
                        <pre><code>
SELECT first_name FROM employees WHERE emp_no + 1 = 11001;
SELECT first_name FROM employees WHERE emp_no = 11000;

SELECT first_name, hire_date FROM employees WHERE YEAR(CURRENT_DATE) - YEAR(hire_date) <= 14;
SELECT first_name, hire_date FROM employees WHERE hire_date >= DATE_SUB(CURRENT_DATE, INTERVAL 14 YEAR);
SELECT first_name, hire_date FROM employees WHERE hire_date >= DATE_SUB('2013-01-17', INTERVAL 14 YEAR);
                        </code></pre>
                    </section>

                    <section>
                        <h2>Explain</h2>
                        <img src="img/explain_2_6_1.png">
                        <img src="img/explain_2_6_2.png">
                    </section>

                    <section>
                        <h2>Індекси по декількох стовпцях</h2>
                        <pre><code>
SELECT last_name, first_name FROM salaries
LEFT JOIN employees USING(emp_no)
WHERE from_date = '1995-12-03' AND to_date = '1996-12-02'
                        </code></pre>
                    </section>

                    <section>
                        <h2>Багатоколоночні (окремі) індекси vs комбіновані індекси</h2>
                    </section>

                    <section>
                        <h2>Покриваючі індекси</h2>

                        індекс і сортування
                    </section>

                    <section>
                        <h2>Індекс і посторінкова навігація</h2>


                    </section>
                </section>

                <section>
                    <h2>Нормалізація і денормалізація</h2>
                </section>

                <section>
                    <h2>Реплікація</h2>
                </section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
                width: 1200,
                minScale: 1,
                maxScale: 1.0,
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					 //{ src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } },
					 //{ src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
